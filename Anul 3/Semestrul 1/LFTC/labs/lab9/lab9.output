Grammar

    0 $accept: program $end

    1 program: function

    2 function: header compound_statement

    3 header: INT MAIN LPR RPR

    4 compound_statement: LAC instr_comp RAC

    5 instr_comp: instr instr_comp
    6           | instr

    7 instr: assign SEMICOLON
    8      | decl SEMICOLON
    9      | input_instr SEMICOLON
   10      | output_instr SEMICOLON
   11      | return_instr SEMICOLON

   12 assign: ID ASSIGN expr_arit

   13 expr_arit: expr_arit PLUS expr_arit
   14          | expr_arit MINUS expr_arit
   15          | expr_arit MUL expr_arit
   16          | expr_arit DIV expr_arit
   17          | /* empty */
   18          | ID
   19          | CONST

   20 decl: INT ID

   21 input_instr: CIN READ ID

   22 output_instr: COUT WRITE expr_arit

   23 return_instr: RETURN expr_arit


Terminals, with rules where they appear

$end (0) 0
error (256)
INT (258) 3 20
CIN (259) 21
COUT (260) 22
RETURN (261) 23
MAIN (262) 3
ASSIGN (263) 12
SEMICOLON (264) 7 8 9 10 11
LPR (265) 3
RPR (266) 3
LAC (267) 4
RAC (268) 4
READ (269) 21
WRITE (270) 22
ID (271) 12 18 20 21
CONST (272) 19
PLUS (273) 13
MINUS (274) 14
MUL (275) 15
DIV (276) 16


Nonterminals, with rules where they appear

$accept (22)
    on left: 0
program (23)
    on left: 1, on right: 0
function (24)
    on left: 2, on right: 1
header (25)
    on left: 3, on right: 2
compound_statement (26)
    on left: 4, on right: 2
instr_comp (27)
    on left: 5 6, on right: 4 5
instr (28)
    on left: 7 8 9 10 11, on right: 5 6
assign (29)
    on left: 12, on right: 7
expr_arit (30)
    on left: 13 14 15 16 17 18 19, on right: 12 13 14 15 16 22 23
decl (31)
    on left: 20, on right: 8
input_instr (32)
    on left: 21, on right: 9
output_instr (33)
    on left: 22, on right: 10
return_instr (34)
    on left: 23, on right: 11


state 0

    0 $accept: . program $end

    INT  shift, and go to state 1

    program   go to state 2
    function  go to state 3
    header    go to state 4


state 1

    3 header: INT . MAIN LPR RPR

    MAIN  shift, and go to state 5


state 2

    0 $accept: program . $end

    $end  shift, and go to state 6


state 3

    1 program: function .

    $default  reduce using rule 1 (program)


state 4

    2 function: header . compound_statement

    LAC  shift, and go to state 7

    compound_statement  go to state 8


state 5

    3 header: INT MAIN . LPR RPR

    LPR  shift, and go to state 9


state 6

    0 $accept: program $end .

    $default  accept


state 7

    4 compound_statement: LAC . instr_comp RAC

    INT     shift, and go to state 10
    CIN     shift, and go to state 11
    COUT    shift, and go to state 12
    RETURN  shift, and go to state 13
    ID      shift, and go to state 14

    instr_comp    go to state 15
    instr         go to state 16
    assign        go to state 17
    decl          go to state 18
    input_instr   go to state 19
    output_instr  go to state 20
    return_instr  go to state 21


state 8

    2 function: header compound_statement .

    $default  reduce using rule 2 (function)


state 9

    3 header: INT MAIN LPR . RPR

    RPR  shift, and go to state 22


state 10

   20 decl: INT . ID

    ID  shift, and go to state 23


state 11

   21 input_instr: CIN . READ ID

    READ  shift, and go to state 24


state 12

   22 output_instr: COUT . WRITE expr_arit

    WRITE  shift, and go to state 25


state 13

   23 return_instr: RETURN . expr_arit

    ID     shift, and go to state 26
    CONST  shift, and go to state 27

    $default  reduce using rule 17 (expr_arit)

    expr_arit  go to state 28


state 14

   12 assign: ID . ASSIGN expr_arit

    ASSIGN  shift, and go to state 29


state 15

    4 compound_statement: LAC instr_comp . RAC

    RAC  shift, and go to state 30


state 16

    5 instr_comp: instr . instr_comp
    6           | instr .

    INT     shift, and go to state 10
    CIN     shift, and go to state 11
    COUT    shift, and go to state 12
    RETURN  shift, and go to state 13
    ID      shift, and go to state 14

    $default  reduce using rule 6 (instr_comp)

    instr_comp    go to state 31
    instr         go to state 16
    assign        go to state 17
    decl          go to state 18
    input_instr   go to state 19
    output_instr  go to state 20
    return_instr  go to state 21


state 17

    7 instr: assign . SEMICOLON

    SEMICOLON  shift, and go to state 32


state 18

    8 instr: decl . SEMICOLON

    SEMICOLON  shift, and go to state 33


state 19

    9 instr: input_instr . SEMICOLON

    SEMICOLON  shift, and go to state 34


state 20

   10 instr: output_instr . SEMICOLON

    SEMICOLON  shift, and go to state 35


state 21

   11 instr: return_instr . SEMICOLON

    SEMICOLON  shift, and go to state 36


state 22

    3 header: INT MAIN LPR RPR .

    $default  reduce using rule 3 (header)


state 23

   20 decl: INT ID .

    $default  reduce using rule 20 (decl)


state 24

   21 input_instr: CIN READ . ID

    ID  shift, and go to state 37


state 25

   22 output_instr: COUT WRITE . expr_arit

    ID     shift, and go to state 26
    CONST  shift, and go to state 27

    $default  reduce using rule 17 (expr_arit)

    expr_arit  go to state 38


state 26

   18 expr_arit: ID .

    $default  reduce using rule 18 (expr_arit)


state 27

   19 expr_arit: CONST .

    $default  reduce using rule 19 (expr_arit)


state 28

   13 expr_arit: expr_arit . PLUS expr_arit
   14          | expr_arit . MINUS expr_arit
   15          | expr_arit . MUL expr_arit
   16          | expr_arit . DIV expr_arit
   23 return_instr: RETURN expr_arit .

    PLUS   shift, and go to state 39
    MINUS  shift, and go to state 40
    MUL    shift, and go to state 41
    DIV    shift, and go to state 42

    $default  reduce using rule 23 (return_instr)


state 29

   12 assign: ID ASSIGN . expr_arit

    ID     shift, and go to state 26
    CONST  shift, and go to state 27

    $default  reduce using rule 17 (expr_arit)

    expr_arit  go to state 43


state 30

    4 compound_statement: LAC instr_comp RAC .

    $default  reduce using rule 4 (compound_statement)


state 31

    5 instr_comp: instr instr_comp .

    $default  reduce using rule 5 (instr_comp)


state 32

    7 instr: assign SEMICOLON .

    $default  reduce using rule 7 (instr)


state 33

    8 instr: decl SEMICOLON .

    $default  reduce using rule 8 (instr)


state 34

    9 instr: input_instr SEMICOLON .

    $default  reduce using rule 9 (instr)


state 35

   10 instr: output_instr SEMICOLON .

    $default  reduce using rule 10 (instr)


state 36

   11 instr: return_instr SEMICOLON .

    $default  reduce using rule 11 (instr)


state 37

   21 input_instr: CIN READ ID .

    $default  reduce using rule 21 (input_instr)


state 38

   13 expr_arit: expr_arit . PLUS expr_arit
   14          | expr_arit . MINUS expr_arit
   15          | expr_arit . MUL expr_arit
   16          | expr_arit . DIV expr_arit
   22 output_instr: COUT WRITE expr_arit .

    PLUS   shift, and go to state 39
    MINUS  shift, and go to state 40
    MUL    shift, and go to state 41
    DIV    shift, and go to state 42

    $default  reduce using rule 22 (output_instr)


state 39

   13 expr_arit: expr_arit PLUS . expr_arit

    ID     shift, and go to state 26
    CONST  shift, and go to state 27

    $default  reduce using rule 17 (expr_arit)

    expr_arit  go to state 44


state 40

   14 expr_arit: expr_arit MINUS . expr_arit

    ID     shift, and go to state 26
    CONST  shift, and go to state 27

    $default  reduce using rule 17 (expr_arit)

    expr_arit  go to state 45


state 41

   15 expr_arit: expr_arit MUL . expr_arit

    ID     shift, and go to state 26
    CONST  shift, and go to state 27

    $default  reduce using rule 17 (expr_arit)

    expr_arit  go to state 46


state 42

   16 expr_arit: expr_arit DIV . expr_arit

    ID     shift, and go to state 26
    CONST  shift, and go to state 27

    $default  reduce using rule 17 (expr_arit)

    expr_arit  go to state 47


state 43

   12 assign: ID ASSIGN expr_arit .
   13 expr_arit: expr_arit . PLUS expr_arit
   14          | expr_arit . MINUS expr_arit
   15          | expr_arit . MUL expr_arit
   16          | expr_arit . DIV expr_arit

    PLUS   shift, and go to state 39
    MINUS  shift, and go to state 40
    MUL    shift, and go to state 41
    DIV    shift, and go to state 42

    $default  reduce using rule 12 (assign)


state 44

   13 expr_arit: expr_arit . PLUS expr_arit
   13          | expr_arit PLUS expr_arit .
   14          | expr_arit . MINUS expr_arit
   15          | expr_arit . MUL expr_arit
   16          | expr_arit . DIV expr_arit

    MUL  shift, and go to state 41
    DIV  shift, and go to state 42

    $default  reduce using rule 13 (expr_arit)


state 45

   13 expr_arit: expr_arit . PLUS expr_arit
   14          | expr_arit . MINUS expr_arit
   14          | expr_arit MINUS expr_arit .
   15          | expr_arit . MUL expr_arit
   16          | expr_arit . DIV expr_arit

    MUL  shift, and go to state 41
    DIV  shift, and go to state 42

    $default  reduce using rule 14 (expr_arit)


state 46

   13 expr_arit: expr_arit . PLUS expr_arit
   14          | expr_arit . MINUS expr_arit
   15          | expr_arit . MUL expr_arit
   15          | expr_arit MUL expr_arit .
   16          | expr_arit . DIV expr_arit

    $default  reduce using rule 15 (expr_arit)


state 47

   13 expr_arit: expr_arit . PLUS expr_arit
   14          | expr_arit . MINUS expr_arit
   15          | expr_arit . MUL expr_arit
   16          | expr_arit . DIV expr_arit
   16          | expr_arit DIV expr_arit .

    $default  reduce using rule 16 (expr_arit)
